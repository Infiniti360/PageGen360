import { POM, POMResult } from '../types';
import { Logger } from './Logger';
import * as fs from 'fs';
import * as path from 'path';

export class FileGenerator {
  private logger: Logger;

  constructor() {
    this.logger = new Logger();
  }

  /**
   * Generate and save POM files
   */
  async generateFiles(result: POMResult, outputDir: string = './generated-pom'): Promise<{
    pomClassFile: string;
    testFile: string;
    metadataFile: string;
  }> {
    try {
      // Check if POM generation was successful
      if (!result.success) {
        this.logger.error('POM generation failed, cannot generate files');
        throw new Error('POM generation failed. Please check the error messages above and try again.');
      }

      // Check if POM object exists and has required properties
      this.logger.debug(`Validating POM object: success=${result.success}, pom=${!!result.pom}`);
      if (result.pom) {
        this.logger.debug(`POM properties: className=${result.pom.className}, elements=${!!result.pom.elements}, methods=${!!result.pom.methods}`);
      }
      
      if (!result.pom || 
          !result.pom.className || 
          !result.pom.elements || 
          !result.pom.methods ||
          !Array.isArray(result.pom.elements) ||
          !Array.isArray(result.pom.methods)) {
        this.logger.error('POM object is incomplete, cannot generate files');
        throw new Error('POM generation failed - incomplete POM object. Please check the error messages above and try again.');
      }

      // Create output directory if it doesn't exist
      if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
        this.logger.debug(`Created output directory: ${outputDir}`);
      }

      const pom = result.pom;
      const className = pom.className;

      // Generate POM class file using the generated code from CodeGenerator
      let pomClassContent: string;
      this.logger.debug(`POM generatedCode available: ${!!pom.generatedCode}`);
      if (pom.generatedCode) {
        // Use the code generated by CodeGenerator
        this.logger.debug('Using generated code from CodeGenerator');
        pomClassContent = this.generatePOMClassContentFromGeneratedCode(pom);
      } else {
        // Fallback to generating content manually
        this.logger.debug('Using fallback code generation');
        pomClassContent = this.generatePOMClassContentFromCode(pom);
      }
      const pomClassFile = path.join(outputDir, `${className}.${this.getFileExtension(pom.language)}`);
      fs.writeFileSync(pomClassFile, pomClassContent);
      this.logger.debug(`Generated POM class file: ${pomClassFile}`);

      // Generate test file
      const testContent = this.generateTestContent(pom);
      const testFile = path.join(outputDir, `${className}.test.${this.getFileExtension(pom.language)}`);
      fs.writeFileSync(testFile, testContent);
      this.logger.debug(`Generated test file: ${testFile}`);

      // Generate metadata file
      const metadataContent = this.generateMetadataContent(result);
      const metadataFile = path.join(outputDir, `${className}.metadata.json`);
      fs.writeFileSync(metadataFile, metadataContent);
      this.logger.debug(`Generated metadata file: ${metadataFile}`);

      return {
        pomClassFile,
        testFile,
        metadataFile
      };

    } catch (error) {
      this.logger.error(`Error generating files: ${error}`);
      throw error;
    }
  }

  /**
   * Generate POM class content from generated code
   */
  private generatePOMClassContentFromGeneratedCode(pom: POM): string {
    if (!pom.generatedCode) {
      throw new Error('No generated code available');
    }
    
    // Use the code generated by CodeGenerator directly
    return pom.generatedCode;
  }

  /**
   * Generate POM class content from CodeGenerator
   */
  private generatePOMClassContentFromCode(pom: POM): string {
    const { className, imports } = pom;

    let content = '';

    // Add imports (handle undefined imports)
    if (imports && Array.isArray(imports)) {
      content += imports.join('\n') + '\n\n';
    } else {
      // Default imports based on framework
      switch (pom.framework) {
        case 'playwright':
          content += `import { Page, Locator } from "playwright";\n\n`;
          break;
        case 'selenium':
          content += `import { WebDriver, WebElement, By, until } from "selenium-webdriver";\n\n`;
          break;
        case 'cypress':
          content += `// Cypress Page Object Model\n\n`;
          break;
        default:
          content += `// Framework: ${pom.framework}\n\n`;
      }
    }

    // Add class definition
    content += `export class ${className} {\n`;

    // Add constructor
    content += this.generateConstructor(pom.framework, pom.language);

    // Add element locators
    content += '\n  // Element Locators\n';
    if (pom.elements && Array.isArray(pom.elements)) {
      pom.elements.forEach(element => {
        if (element.isInteractive) {
          const elementName = this.generateElementName(element);
          const selector = element.cssSelector || element.xpath || `[data-testid="${element.elementId}"]`;
          if (pom.framework === 'cypress') {
            content += `  get ${elementName}() { return cy.get('${selector}'); }\n`;
          } else {
            content += `  private ${elementName} = '${selector}';\n`;
          }
        }
      });
    }

    // Add methods using the generated code from CodeGenerator
    content += '\n  // Methods\n';
    if (pom.methods && Array.isArray(pom.methods)) {
      pom.methods.forEach(method => {
        content += this.generateMethodContentFromCode(method, pom.framework, pom.language);
      });
    }

    content += '}\n';

    return content;
  }



  /**
   * Generate test content
   */
  private generateTestContent(pom: POM): string {
    const { className } = pom;

    let content = '';

    // Add imports based on framework
    switch (pom.framework) {
      case 'playwright':
        content += `import { test, expect } from '@playwright/test';\n`;
        content += `import { ${className} } from './${className}';\n\n`;
        break;
      case 'selenium':
        content += `import { Builder, By, until } from 'selenium-webdriver';\n`;
        content += `import { ${className} } from './${className}';\n\n`;
        break;
      case 'cypress':
        content += `// Cypress Test File\n\n`;
        break;
    }

    // Add test class/function
    switch (pom.framework) {
      case 'playwright':
        content += `test.describe('${className} Tests', () => {\n`;
        content += `  let page: Page;\n`;
        content += `  let pom: ${className};\n\n`;
        content += `  test.beforeEach(async ({ page: testPage }) => {\n`;
        content += `    page = testPage;\n`;
        content += `    pom = new ${className}(page);\n`;
        content += `    await page.goto('${pom.url}');\n`;
        content += `  });\n\n`;
        content += `  test('should load page successfully', async () => {\n`;
        content += `    await expect(page).toHaveTitle(/.*/);\n`;
        content += `  });\n`;
        content += `});\n`;
        break;
      case 'selenium':
        content += `describe('${className} Tests', () => {\n`;
        content += `  let driver: WebDriver;\n`;
        content += `  let pom: ${className};\n\n`;
        content += `  beforeAll(async () => {\n`;
        content += `    driver = await new Builder().forBrowser('chrome').build();\n`;
        content += `    pom = new ${className}(driver);\n`;
        content += `    await driver.get('${pom.url}');\n`;
        content += `  });\n\n`;
        content += `  afterAll(async () => {\n`;
        content += `    await driver.quit();\n`;
        content += `  });\n\n`;
        content += `  test('should load page successfully', async () => {\n`;
        content += `    const title = await driver.getTitle();\n`;
        content += `    expect(title).toBeTruthy();\n`;
        content += `  });\n`;
        content += `});\n`;
        break;
      case 'cypress':
        content += `describe('${className} Tests', () => {\n`;
        content += `  const pom = new ${className}();\n\n`;
        content += `  beforeEach(() => {\n`;
        content += `    cy.visit('${pom.url}');\n`;
        content += `  });\n\n`;
        content += `  it('should load page successfully', () => {\n`;
        content += `    cy.title().should('exist');\n`;
        content += `  });\n\n`;
        content += `  it('should have interactive elements', () => {\n`;
        content += `    // Test that elements are accessible\n`;
        content += `    cy.get('body').should('be.visible');\n`;
        content += `  });\n`;
        content += `});\n`;
        break;
    }

    return content;
  }

  /**
   * Generate metadata content
   */
  private generateMetadataContent(result: POMResult): string {
    return JSON.stringify({
      success: result.success,
      pom: {
        id: result.pom.id,
        url: result.pom.url,
        version: result.pom.version,
        framework: result.pom.framework,
        language: result.pom.language,
        className: result.pom.className,
        elementCount: result.pom.elements.length,
        methodCount: result.pom.methods.length,
        generatedAt: result.pom.generatedAt,
        metadata: result.pom.metadata
      },
      warnings: result.warnings,
      errors: result.errors,
      metadata: result.metadata
    }, null, 2);
  }

  /**
   * Generate constructor
   */
  private generateConstructor(_framework: string, _language: string): string {
    switch (_framework) {
      case 'playwright':
        return `  constructor(private page: Page) {}\n\n`;
      case 'selenium':
        return `  constructor(private driver: WebDriver) {}\n\n`;
      case 'cypress':
        return `  constructor() {}\n\n`;
      default:
        return `  constructor() {}\n\n`;
    }
  }

  /**
   * Generate method content from CodeGenerator
   */
  private generateMethodContentFromCode(method: any, framework: string, _language: string): string {
    let content = `  ${method.description}\n`;
    
    if (framework === 'cypress') {
      content += `  ${method.name}(`;
      
      if (method.parameters && method.parameters.length > 0) {
        content += method.parameters.map((param: any) => 
          `${param.name}${param.required ? '' : '?'}: ${param.type}`
        ).join(', ');
      }
      
      content += `) {\n`;
      content += `    ${method.body}\n`;
      content += `  }\n\n`;
    } else {
      content += `  async ${method.name}(`;
      
      if (method.parameters && method.parameters.length > 0) {
        content += method.parameters.map((param: any) => 
          `${param.name}${param.required ? '' : '?'}: ${param.type}`
        ).join(', ');
      }
      
      content += `): Promise<${method.returnType}> {\n`;
      content += `    ${method.body}\n`;
      content += `  }\n\n`;
    }
    
    return content;
  }



  /**
   * Generate element name
   */
  private generateElementName(element: any): string {
    if (element.elementId) {
      return element.elementId;
    }
    if (element.text) {
      return element.text.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
    }
    return `${element.tagName}${Math.random().toString(36).substr(2, 5)}`;
  }

  /**
   * Get file extension based on language
   */
  private getFileExtension(language: string): string {
    switch (language) {
      case 'typescript':
        return 'ts';
      case 'javascript':
        return 'js';
      case 'python':
        return 'py';
      case 'java':
        return 'java';
      case 'csharp':
        return 'cs';
      default:
        return 'ts';
    }
  }
} 